# Example Data
### Serialization
We are planning on using serialization to store all internal ‘game objects’. As such, the format of this file will likely consist of some sort of hierarchal content tree, but will ultimately be defined however the serialization framework we choose to use functions. There will be one such structure for each game as authored by our authoring engine. 
### Other Files and File Hierarchy
The only files thus that will need to worked with external to these xml files will be resource/content files for each game for things that are read in by our serialized code like images and then xml files that we will use and construct by hand in order to drive the behavior of our interfaces from data. Java resource bundles (and thus simple text files to hold the key value associations) will be used to avoid hardcoded strings through our project.
Image files will be in the jpeg and png image file formats throughout our project. The general file structure to organize this, in the same folder as the src folder, there is a folder called RESOURCES. There is a folder called GAMES upon which a folder for each game created in our program is created, named after that game. The format for these game folders is the same, sub folder called Images, GuiOptions (where the xml property files go) and lastly a folder called ResourceBundles. There is lastly in the same folder as games, a folder called GitDepends with the same structure as the game folders, to hold any files that are used by the game authoring engine itself. 
### Defining GUI behavior using XML Property Files
We are as of now planning on using xml property files in order to facilitate class construction using reflection. We will use these files to specify which classes should be viewed as options for certain dialogue options, and to generate the GUI interfaces needed to actually grab user specifiable input. To make this concrete, let us examine what happens when the user of our program attempts to select a movement strategy for a sprite that they are constructing. This will cause the frontend to query the MovementStrategyList.xml in the GuiOptions file for the game that the user is working on, which will have input into it by hand by the backend team the path names of all modules created that are to be considered MovementStrategies. There will also be input into this file a string that is used as the nice display name by the front end. Now the gui will create a drop down box with these display names, and upon selection, will use reflection to interrogate the constructor for this class and will generate using factory methods the necessary gui objects needed to take in the information from the user. This can recursively handle construction of the interface for needed sub objects. 

